<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Feature Space Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <h2 id="vis-title">Latent Space Visualization</h2>
  </header>

  <section class="controls" aria-label="Visualization controls">
    <button id="reset-zoom">Reset Zoom</button>
    <button id="download-png">Download PNG</button>
    <span id="status" aria-live="polite"></span>
  </section>

  <main class="viz-container" id="viz" role="img" aria-label="Scatter plot of feature embeddings">
    <img id="hover-img" class="scatter-img" alt="Preview image">
    <div id="tooltip" class="tooltip" role="status" aria-hidden="true"></div>
  </main>

  <footer>
    <div id="legend" class="legend"></div>
    <div id="fallback" class="fallback" style="display:none;"></div>
  </footer>

  <script>
    d3.json("embedding_data/pc2vspc3_d3.json").then(data => {
      if (!data || data.length === 0) {
        d3.select('#fallback').style('display', 'block')
          .text('No data found in d3_data.json.');
        return;
      }
    
      const container = d3.select('#viz');
      const width = 800, height = 520;
      const margin = { top: 20, right: 20, bottom: 50, left: 60 };
    
      const svg = container.append('svg')
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');
    
      const innerW = width - margin.left - margin.right;
      const innerH = height - margin.top - margin.bottom;
    
      const g = svg.append('g')
        .attr('class', 'chart-content')
        .attr('transform', `translate(${margin.left},${margin.top})`);
    
      // scales
      const x = d3.scaleLinear()
        .domain(d3.extent(data, d => +d.x)).nice()
        .range([0, innerW]);
    
      const y = d3.scaleLinear()
        .domain(d3.extent(data, d => +d.y)).nice()
        .range([innerH, 0]);
    
      const color = d3.scaleOrdinal()
        .domain([...new Set(data.map(d => d.label))])
        .range(["gold", "purple"]);
    
      // axes
      const xAxis = g.append('g')
        .attr('class', 'x-axis')
        .attr('transform', `translate(0,${innerH})`)
        .call(d3.axisBottom(x).ticks(6));
    
      const yAxis = g.append('g')
        .attr('class', 'y-axis')
        .call(d3.axisLeft(y).ticks(6));
    
      g.append('text')
        .attr('class', 'axis-label')
        .attr('x', innerW / 2)
        .attr('y', innerH + 40)
        .attr('text-anchor', 'middle')
        .text('Feature 1');
    
      g.append('text')
        .attr('class', 'axis-label')
        .attr('x', -innerH / 2)
        .attr('y', -44)
        .attr('transform', 'rotate(-90)')
        .attr('text-anchor', 'middle')
        .text('Feature 2');
    
      // tooltip and hover image
      const tooltip = d3.select('#tooltip');
      const hoverImg = d3.select('#hover-img');
    
      // points
      const pointsGroup = g.append('g').attr('class', 'points');
    
      pointsGroup.selectAll('circle')
        .data(data)
        .join('circle')
        .attr('cx', d => x(+d.x))
        .attr('cy', d => y(+d.y))
        .attr('r', 5)
        .attr('fill', d => color(d.label))
        .attr('opacity', 0.9)
        .on('mouseenter', function(event, d) {
          d3.select(this).classed('highlighted', true);
          const [mx, my] = d3.pointer(event, container.node());
          showTooltip(d, mx, my);
        })
        .on('mousemove', (event, d) => {
          const [mx, my] = d3.pointer(event, container.node());
          movePreview(mx, my, d);
          showTooltip(d, mx, my);
        })
        .on('mouseleave', function() {
          d3.select(this).classed('highlighted', false);
          hidePreview();
          tooltip.style('display', 'none');
        });

      // legend
      const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', `translate(${width - 80}, 0)`);
    
      const labelMap = { 0: "Normal", 1: "Abnormal" };
      const categories = color.domain();
    
      categories.forEach((cat, i) => {
        const legendRow = legend.append('g')
          .attr('class', 'legend-row')
          .attr('transform', `translate(0, ${i * 20})`)
          .style('cursor', 'pointer')
          .on('click', function() {
            const active = d3.select(this).classed('inactive');
            d3.select(this).classed('inactive', !active);
            pointsGroup.selectAll('circle')
              .filter(d => d.label === cat)
              .transition().duration(200)
              .style('opacity', active ? 0.9 : 0.08)
              .attr('pointer-events', active ? 'auto' : 'none');
          });
    
        legendRow.append('rect')
          .attr('width', 12)
          .attr('height', 12)
          .attr('fill', color(cat));
    
        legendRow.append('text')
          .attr('x', 18)
          .attr('y', 10)
          .attr('font-size', 12)
          .text(labelMap[cat] ?? cat);
      });
    
      // zoom behavior
      const zoom = d3.zoom()
        .scaleExtent([0.5, 20])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
          xAxis.call(d3.axisBottom(x).scale(event.transform.rescaleX(x)));
          yAxis.call(d3.axisLeft(y).scale(event.transform.rescaleY(y)));
        });
    
      svg.call(zoom);
    
      // --- reset zoom ---
      d3.select('#reset-zoom').on('click', () => {
        svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(100, 20).scale(0.80))
        xAxis.transition().duration(500).call(d3.axisBottom(x));
        yAxis.transition().duration(500).call(d3.axisLeft(y));
      });
    
      d3.select('#status').text(`${data.length} points loaded.`);
    
      // --- tooltip and image helpers ---
      function showTooltip(d, mx, my) {
        const text = `ID: ${d.a_id ?? d.id ?? "N/A"} | Label: ${labelMap[d.label] ?? d.label}`;
        tooltip.style('display', 'block')
               .style('left', (mx + 12) + 'px')
               .style('top', (my + 12) + 'px')
               .text(text);
        movePreview(mx, my, d);
      }
    
      function movePreview(mx, my, d) {
        if (!d.img) { hidePreview(); return; }
        const containerRect = container.node().getBoundingClientRect();
        const imgW = Math.min(480, containerRect.width * 0.6);
        const imgH = imgW;
        hoverImg.attr('src', d.img)
                .style('display', 'block')
                .style('width', imgW + 'px')
                .style('height', 'auto')
                .style('left', (mx + 15) + 'px')
                .style('top', (my + 15) + 'px');
      }
    
      function hidePreview() {
        hoverImg.style('display', 'none').attr('src', '');
      }
    
      // download as PNG
      d3.select('#download-png').on('click', () => {
        const svgNode = svg.node();
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgNode);
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        const img = new Image();
        const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        img.onload = function() {
          ctx.fillStyle = '#fff';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0);
          URL.revokeObjectURL(url);
          const a = document.createElement('a');
          a.download = 'latent_space.png';
          a.href = canvas.toDataURL('image/png');
          a.click();
        };
        img.src = url;
      });
    
    }).catch(err => {
      d3.select('#fallback')
        .style('display', 'block')
        .text('Failed to load data: ' + err.message);
    });
    </script>
    
</body>
</html>
